Here, you'll learn how to remove workflow artifacts from GitHub and change the default retention period. Next, you'll learn how to create a workflow status badge and add it to your `README.md` file. Finally, you'll identify some important workflow environment protections and how to enable them. 

## Remove workflow artifacts from GitHub

By default, GitHub stores any build logs and uploaded artifacts for 90 days before they are deleted. You can customize this retention period based on the type of repository and the usage limits set for your specific GitHub product. There is a lot more information regarding usage limits and artifact retention than makes sense to cover here, so check out [Usage limits, billing, and administration](https://docs.github.com/en/actions/reference/usage-limits-billing-and-administration) for more information.

But let's say you're reaching your organization’s storage limit for GitHub artifacts and packages and you want to remove old artifacts without increasing your usage limits and blocking your workflows. You can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub. You can do this two ways, as described in the following sections. Please note that both methods require write access to the repository.

> [!WARNING]
> Keep in mind that once you delete an artifact, it can not be restored.

### Manually delete artifacts from your repository

To manually delete an artifact on GitHub, navigate to the **Actions** tab, select the workflow from the left sidebar, and then select the run you want to see.

:::image type="content" source="../media/select-workflow-run.png" alt-text="Screenshot that shows an example workflow run on GitHub.":::

Under **Artifacts**, delete the artifact you want to remove.

:::image type="content" source="../media/delete-artifact.png" alt-text="Screenshot that shows the trash can icon to delete an artifact on GitHub.":::

You can also use the Artifacts REST API to delete artifacts. This API will also allow you to download and retrieve information about work artifacts.

### Change the default retention period

You can change the default artifact and log retention period for your repository, organization, or enterprise account. Keep in mind that changing the retention period will only apply to new artifacts and log files, and does not apply to existing objects. The process to configure these settings is a bit different for a repository, organization, or enterprise. Check the summary at the end of this module for more information on configuring artifacts and log retentions.

In addition to configured settings across a repository, organization, or enterprise, you can define a custom retention period for individual artifacts right within the workflow file. This is good for individual use cases where you want a specific artifact's retention to be different than the default or configured setting. You can do this using `retention-days` and then a value within the step with the `upload-artifact` action.

The following example uploads an artifact that will persist for 10 days instead of the default 90 days:

```yml
- name: 'Upload Artifact'
  uses: actions/upload-artifact@v2
  with:
    name: my-artifact
    path: my_file.txt
    retention-days: 10
```

## Supercharge job summaries

Job Summaries allow for custom markdown content on the run summary generated by each job. Custom markdown content can be used for aggregating and displaying test results, generating reports, and custom output independent of logs. 

Any markdown content added to a file utilizing `$GITHUB_STEP_SUMMARY` will be displayed on the Actions run summary page. Here is an example:

```
steps:
  - name: Adding markdown
    run: echo '### Hello world! :rocket:' >> $GITHUB_STEP_SUMMARY
```

Job Summaries have a helper utility to the `@actions/core` npm package. This utility allows authors to easily add individual lines or blocks of markdown. Also it's easy to generate tables, for this very common scenario. Here is an example:

```
import * as core from '@actions/core' 
  await core.summary
  .addHeading('Test Results')
  .addCodeBlock(generateTestResults(), "js")
  .addTable([
    [{data: 'File', header: true}, {data: 'Result', header: true}],
    ['foo.js', 'Pass ✅'],
    ['bar.js', 'Fail ❌'],
    ['test.js', 'Pass ✅']
  ])
  .addLink('View staging deployment!', 'https://github.com')
  .write()
```

## Add a workflow status badge to your repository

It's helpful to know the status of a workflow without having to visit the **Actions** tab to see if it successfully completed. Adding workflow status badges to your repository `README.md` file allows you to quickly see if your workflows are passing or failing. While it's common to add a status badge to a repository `README.md` file, you can also add it any web page. By default, status badges display the workflow statuses on your default branch, but you can also display workflow status badges on other branches using the `branch` and `event` parameters.

Here's an example of what you'd need to add to a file to see a workflow status badge: 

```yml
![example branch parameter.](https://github.com/mona/special-octo-eureka/actions/workflows/grading.yml/badge.svg?branch=my-workflow)
```

For example, adding the `branch` parameter along with the desired branch name at the end of the URL will show the workflow status badge for that branch instead of the default branch. This makes it easy to create a table-like view within your `README.md` file to display workflow statuses based on branches, events, services, or environments to name a few.

:::image type="content" source="../media/my-workflow-status-badge.png" alt-text="Screenshot that shows an example workflow status badge with the my-workflow branch.":::

You also have the ability to create a status badge using GitHub. To do this, navigate to the workflows section within the **Actions** tab and select a specific workflow. The **Create status badge** option will allow you to generate the markdown for that workflow and set the `branch` and `event` parameters.

:::image type="content" source="../media/create-status-badge.png" alt-text="Screenshot that shows the option to create a status badge from the workflows section on GitHub.":::

## Add workflow environment protections

Security is a big deal, so it makes sense to configure your workflow environment with protection rules and secrets. With these in place, a job won't start or access any defined secrets in the environment until all of the environment's protection rules pass. Currently, protection rules and environment secrets only apply to public repositories.

There are two environment protection rules that you can apply to workflows within public repositories, **required reviewers** and **wait timer**.
 
- **Required reviewers** allow you to set a specific person or team to approve workflow jobs that reference the job's environment. 
- **Wait timer** can be used to delay a job for a specific amount of time after the job has been triggered. 

So, for example, let's say you need to create a workflow to a production environment that a dev team needs to approve before the deployment occurs. The steps would look like this:

1. Create a production environment within the repository.
2. Configure the required reviewers environment protection to require an approval from the specific dev team.
3. Configure the specific job within the workflow to look for the production environment.

GitHub Actions lets you control the permissions granted to the `GITHUB_TOKEN` secret. The `GITHUB_TOKEN` is an automatically generated secret letting you make authenticated calls to the GitHub API in your workflow runs. Actions generates a new token for each job and expires the token when a job completes. These new settings allow you to follow a principle of least privilege in your workflows. The token has `write` permissions to a number of API endpoints except in the case of pull requests from forks which are always `read`.

You can create and configure new repository environments from the repository's **Settings** tab under **Environments**.

GitHub Actions simplifies using secrets with reusable workflows with the secrets: `inherit keyword`. You can simply pass the `secrets: inherit` to the reusable workflow and the secrets will be inherited from the calling workflow.

Next, we'll do an exercise that checks your knowledge on content covered in this module by using GitHub Actions and Microsoft Azure to create two deployment workflows.
